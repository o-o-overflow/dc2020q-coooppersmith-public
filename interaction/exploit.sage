#!/usr/bin/env sage
from sage.all import inverse_mod, lcm, PolynomialRing, Zmod, is_prime
from pwn import remote, process
import sys
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_v1_5
from binascii import unhexlify, hexlify

PREFIX_MSG = "length no more than "
KEY_MSG = "Your public key:\n"
FLAG_MSG = "Your flag message:"
QUESTION_MSG = "Question:"
END_PUB_KEY = "-----END RSA PUBLIC KEY-----"
PRIV_KEY_MSG = "Your private key:\n"
END_PRIV_KEY = "-----END RSA PRIVATE KEY-----"
msg = ""


def remote_connect():
    host = sys.argv[1]
    port = int(sys.argv[2])
    return remote(host, port)


def calculate_d(n, p):
    assert n % p == 0
    q = n / p
    return long(inverse_mod(65537, lcm(p-1, q-1)))


def find_ddd(n):
    with open('sss', 'r') as f:
        l = f.readline().strip()
        while l != "":
            s = int(l, 16)
            d = find_dd(n, s) 
            if d is not None:
                print(hex(s))
                return d 
            l = f.readline().strip()
    return None

def find_dd(n, s):
    # find prime s with the prefix of [prefix] and in hex length of [prime_len]
    s_inverse = inverse_mod(2 * s, n)
    PR = PolynomialRing(Zmod(n), names=('x',))
    (x,) = PR._first_ngens(1)
    # f = 2 * s * x + 1 -> f = x + (2 * s)^-1 mod n
    f = x + s_inverse
    # print f
    f.small_roots()
    try:
        # find root < 2^k bits with factor >= n^0.4
        xs = f.small_roots(X=s, beta=0.4)
        # X can't be too large like 2 * (s + 1). I don't know why but whatever
        p = xs[0] * 2 * s + 1
        print p
        d = calculate_d(n, long(p))
        return d
    except Exception:
        # raise e
        return None


def receive_pubkey(r):
    global msg
    line = r.recvuntil(KEY_MSG).strip()
    msg += line
    pubkey_str = r.recvuntil(END_PUB_KEY)
    print pubkey_str.strip()
    pubkey = RSA.importKey(pubkey_str.strip())
    return pubkey


def receive_privkey(r):
    global msg
    line = r.recvuntil(PRIV_KEY_MSG).strip()
    msg += line
    pubkey_str = r.recvuntil(END_PRIV_KEY)
    print pubkey_str.strip()
    pubkey = RSA.importKey(pubkey_str.strip())
    return pubkey

def receive_s(r):
    global msg
    line = r.recvuntil("s: ").strip()
    msg += line
    line = r.recvline(keepends=False)
    return int(line, 16)


def receive_flag(r):
    global msg
    line = r.recvuntil(FLAG_MSG).strip()
    print(line)
    msg += line
    r.recvline(keepends=False)
    msg_hex = r.recvline(keepends=False)
    print msg_hex

    return msg_hex


def receive_question(r):
    line = r.recvuntil(QUESTION_MSG).strip()
    print(line)
    r.recvline(keepends=False)
    msg_hex = r.recvline(keepends=False)
    print("question: ")
    print msg_hex

    return msg_hex

def decrypt(ciphertext, pubkey, d):
    private = RSA.construct((pubkey.n, pubkey.e, d))
    decryptor = PKCS1_v1_5.new(private)
    decrypted = decryptor.decrypt(unhexlify(ciphertext), 1)
    return decrypted


def wait_for_response(r):
    global msg
    while True:
        line = r.recvline().strip()
        if len(line) == 0:
            break
        print line
        msg += line
        if line.find("Defender wins") >= 0:
            print "Defender wins"
            break
        elif line.find("Attacker wins") >= 0:
            print "Attacker wins"
            return WIN
        elif line.find("contact OOO") >= 0:
            print "error"
            break
    return LOSE


def set_prefix(length):
    # set prefix with the hex length of [length].
    return 1 << (4 * length - 1)
    # TODO: check why


def send_prefix(prefix, r):
    print("sending %s" % hex(prefix))
    r.sendline(hex(prefix))

def solve(plain):
    words = plain.strip().split()
    number1 = int(words[-1][:-1])
    number2 = int(words[-3])
    return number1 + number2

def send_answer(r, sum):
    r.sendline("%d" % sum)
    # encryptor = PKCS1_v1_5.new(privkey)
    # encrypted = encryptor.encrypt(str(sum))
    # print("sending answer: %d" % sum)
    # print(hexlify(encrypted))
    # r.sendline(encrypted)

def main():
    global msg
    if len(sys.argv) != 3:
        r = process(['./service'])
    else:
        r = remote_connect()
    # print util.proc.pidof(r)
    # raw_input()
    msg += r.recvuntil(PREFIX_MSG)
    print msg
    prefix_msg = r.recvuntil(": ", drop=True)
    msg += prefix_msg

    prefix_len = int(prefix_msg.strip())

    # send a prefix
    prefix = set_prefix(prefix_len)
    send_prefix(prefix, r)

    # receive s
    # JUST FOR DEBUG PURPOSE
    # s = receive_s(r)
    # print("s: ", hex(s))

    # receive pubkey
    pubkey = receive_pubkey(r)

    # receive privatekey
    # JUST FOR DEBUG PURPOSE
    # privkey = receive_privkey(r)
    
    d = find_ddd(pubkey.n)
    
    # receive question
    question = receive_question(r)

    # decrypt question
    plain = decrypt(question, pubkey, d)

    print(plain)

    sum = solve(plain)

    # send answer
    send_answer(r, sum)

    # r.recvuntil("decrypted: ")
    # print("decrypted", r.recvline())
    # r.recvuntil("line: ")
    # print("line:", r.recvline())

    # receiv encrypted flag
    ciphertext = receive_flag(r)
    plaintext = decrypt(ciphertext, pubkey, d)
    print plaintext


if __name__ == "__main__":
    main()
